<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8">
    <title>-clicky-</title>
    <link href="https://fonts.googleapis.com/css?family=Barlow+Semi+Condensed:300,400,700,900" rel="stylesheet">
    <style>
      * {
        margin: 0;
        padding: 0;
        font-family: 'Barlow Semi Condensed', sans-serif;
        color: #fff;
      }

      body {
        display: flex;
        flex-direction: column;
        justify-content: center;
        align-items: center;
        width: 100vw;
        height: 100vh;
        background: #30323D;
      }

      div {
        display: flex;
        justify-content: space-around;
        align-items: center;
        width: 480px;
      }

      span {
        font-size: 2em;
        display: flex;
        flex-direction: column;
        align-items: center;
        justify-content: center;
      }

      p {
        font-size: .7em;
        padding: 20px 0 0 0;
      }

      #canvas {

      }
    </style>
  </head>
  <body>
    <div>
      <span>Score<p id='score'></p></span>
      <span>Accuracy<p id='acc'></p></span>
      <span>Speed<p id='speed'></p></span>
    </div>
    <canvas id="canvas" width="800" height="600"></canvas>
  </body>

  <script src="js/mainloop.min.js"></script>
  <script type="text/javascript">
    var canvas = document.getElementById('canvas');
    var context = canvas.getContext('2d');

    var score = document.getElementById('score');
    var accuracy = document.getElementById('acc');
    var speed = document.getElementById('speed');



    var GAME_STATE = {
      PLAYING : {name:'playing',averageClickTime:0,numberOfClicks:0,accuracy:0,avgCenterDist:0,score:0,timeLeft:0,lastClickTime:0},
      PAUSED  : {name:'paused',time:0,timeLeft:0},
      MENU    : {name:'menu'},
      FAIL    : {name:'fail',xz:0,yz:0,tileIndex:null,time:0,timeLeft:0},
      WIN     : {name:'win',time:0,timeLeft:0}
    };

    var gameState = GAME_STATE.WIN;

    var mouse = {x:'0', y:'0', active:false, pressed:false, released:false};

    function update(delta) {
      map.update(delta);
      mouse.pressed = mouse.released = false;
    }

    function render(interpPerc) {
      context.clearRect(0, 0, canvas.width, canvas.height);
      map.render(interpPerc);
    }

    function begin() {

    }

    function end() {

    }

    function Tile (x, y, tileMap) {
      this.x = x;
      this.y = y;
      this.tileMap = tileMap;
      this.state = 0;
    }

    Tile.prototype.render = function (interpPerc) {
      var xt = this.x * this.tileMap.tileSize + this.tileMap.x;
      var yt = this.y * this.tileMap.tileSize + this.tileMap.y;
      context.tile(xt, yt, this.tileMap.tileSize, this.tileMap.color[this.state]);
    };

    function TileMap(x, y, color, mapSize, tileSize, activeLimit, time) {
      this.x = x;
      this.y = y;
      this.color = color;
      this.mapSize = mapSize;
      this.tileSize = tileSize;
      this.activeLimit = activeLimit;
      this.time = time*1000;

      this.initTiles();
    }

    TileMap.prototype.initTiles = function () {
      score.innerHTML = 0;
      acc.innerHTML = 'WiP';
      speed.innerHTML = 'WiP';
      this.tiles = [];
      for (var ys = 0; ys < this.mapSize; ys++) {
        for (var xs = 0; xs < this.mapSize; xs++) {
          this.tiles.push(new Tile(xs, ys, this));
        }
      }
      GAME_STATE.PLAYING.timeLeft = this.time;
    }

    //----------------------------------------------------------UPDATE----------------------------------------------------------------------
    TileMap.prototype.update = function (delta) {
      var check = (mouse.x >= this.x && mouse.x <= this.tileSize * this.mapSize + this.x) &&
                  (mouse.y >= this.y && mouse.y <= this.tileSize * this.mapSize + this.y);
      switch (gameState.name) {
        case GAME_STATE.PLAYING.name:
          gameState.timeLeft -= delta;
          if(mouse.pressed && check) {
            var mx = Math.floor((mouse.x-this.x) / this.tileSize);
            var my = Math.floor((mouse.y-this.y) / this.tileSize);

            if(mx + my * this.mapSize < this.tiles.length)  {
              if (this.tileCheck(mx+my*this.mapSize) == 0) this.fail(mx+my*this.mapSize);
              else {
                this.activateTiles(1);
                this.tiles[mx+my*this.mapSize].state = 0;
                gameState.numberOfClicks++;
                score.innerHTML = gameState.numberOfClicks;
                //gameState.lastClickTime = (this.time*1000) - gameState.timeLeft;
                //console.log(gameState.averageClickTime,gameState.timeLeft,gameState.lastClickTime);
                //gameState.averageClickTime = (gameState.averageClickTime + (gameState.lastClickTime - gameState.timeLeft)) / 2;
                //speed.innerHTML = Math.round(gameState.averageClickTime/100000);
              }
            }
          }
          if(gameState.timeLeft < 0) this.win();
          break;
        case GAME_STATE.PAUSED.name:
          if(mouse.pressed && check) {
            var mx = Math.floor((mouse.x-this.x) / this.tileSize);
            var my = Math.floor((mouse.y-this.y) / this.tileSize);

            if(mx + my * this.mapSize < this.tiles.length) {
              if(this.tileCheck(mx+my*this.mapSize) == 1) {
                this.activateTiles(1);
                this.tiles[mx+my*this.mapSize].state = 0;
                this.play();
              } else this.fail(mx+my*this.mapSize);
            }
          }
          break;
        case GAME_STATE.WIN.name:
          gameState.time+=delta;

          var time = Math.floor(gameState.time / 100) * 1;
          if(time < this.tiles.length) this.tiles[time].state = 1;
          if(gameState.time > this.tiles.length*100) this.reset();

          break;
        case GAME_STATE.FAIL.name:
          gameState.time += 1 * delta;

          var time = Math.floor(gameState.time / 100) * 1;
          if(time % 2 == 0) this.tiles[gameState.tileIndex].state = 0;
          else this.tiles[gameState.tileIndex].state = 2;

          if(gameState.time > 1500) {
            gameState.time = 0;
            this.reset();
          }
          break;
        case GAME_STATE.MENU.name:

          break;
        default:
      }

    }

    TileMap.prototype.render = function (interpPerc) {
      switch (gameState) {
        case GAME_STATE.PLAYING:
          this.tiles.forEach(function(tile) {
            tile.render(interpPerc);
          });
          context.timer(this);
          //context.dev();
          break;
        case GAME_STATE.PAUSED:
          this.tiles.forEach(function(tile) {
            tile.render(interpPerc);
          });
          context.timer(this);
          break;
        case GAME_STATE.WIN:
          this.tiles.forEach(function(tile) {
            tile.render(interpPerc);
          });
          break;
        case GAME_STATE.FAIL:
          this.tiles.forEach(function(tile) {
            tile.render(interpPerc);
          });
          context.timer(this);
          break;
        case GAME_STATE.MENU:

          break;
        default:
      }
    }

    TileMap.prototype.activateTiles = function (numberOfTiles) {
      while (numberOfTiles > 0) {
        var x = Math.floor(Math.random() * this.mapSize);
        var y = Math.floor(Math.random() * this.mapSize);
        if(this.tiles[x + y * this.mapSize].state == 1) continue;
        else {
          this.tiles[x + y * this.mapSize].state = 1;
          numberOfTiles--;
        }
      }
    }

    TileMap.prototype.tileCheck = function (tileIndex) {
      return this.tiles[tileIndex].state;
    }

    TileMap.prototype.reset = function () {
      this.initTiles();
      this.activateTiles(this.activeLimit);
      GAME_STATE.PAUSED.timeLeft = this.time;
      gameState = GAME_STATE.PAUSED;
    }

    TileMap.prototype.play = function () {
      GAME_STATE.PLAYING.numberOfClicks = 0;
      GAME_STATE.PLAYING.accuracy = 0;
      GAME_STATE.PLAYING.avgCenterDist = 0;
      GAME_STATE.PLAYING.score = 0;
      gameState = GAME_STATE.PLAYING;
    };

    TileMap.prototype.fail = function (tileIndex) {
      GAME_STATE.FAIL.tileIndex = tileIndex;
      GAME_STATE.FAIL.timeLeft = gameState.timeLeft;
      gameState = GAME_STATE.FAIL;
    }

    TileMap.prototype.win = function () {
      GAME_STATE.WIN.time = 0;
      gameState = GAME_STATE.WIN;
    }

    var map = new TileMap(160, 60, ['#CDD1C4','#5C80BC','#E8C547'], 4, 120, 3, 5);

    CanvasRenderingContext2D.prototype.tile = function(x, y, size, color) {
      this.beginPath();
      this.rect(x, y, size, size);
      this.strokeStyle = 'black';
      this.fillStyle = color;
      this.lineWidth = 1;
      this.stroke();
      this.fill();
    }

    CanvasRenderingContext2D.prototype.dev = function () {
      this.beginPath();
      this.arc(mouse.x, mouse.y, 5, 0, Math.PI * 2, true);
      this.fillStyle = 'black';
      this.fill();
    }

    CanvasRenderingContext2D.prototype.timer = function (map) {
      this.beginPath();
      this.lineWidth = 6;
      this.moveTo(map.x, 1+this.lineWidth/2+map.y + (map.mapSize * map.tileSize));
      this.lineTo(map.x + (map.mapSize * map.tileSize)*(gameState.timeLeft / map.time), 1+this.lineWidth/2+(map.y + (map.mapSize * map.tileSize)));
      this.strokeStyle = 'rgb('+Math.round(255-255*(gameState.timeLeft/map.time))+','+Math.round(255*(gameState.timeLeft/map.time))+',0)';
      this.stroke();
      this.closePath();
    }

    document.body.onmousedown = function(event) {
      var rect = canvas.getBoundingClientRect();
      mouse.x = event.clientX - rect.left;
      mouse.y = event.clientY - rect.top;
      if(!mouse.active) mouse.pressed = true;
      mouse.active = true;
    }
    document.body.onmouseup = function() {
      if(mouse.active) mouse.released = true;
      mouse.active = false;
    }

    MainLoop.setBegin(begin).setUpdate(update).setDraw(render).setEnd(end).start();
  </script>
</html>
